uint8_t ledColor[12]; //массив цветов
uint8_t ledBright[4]; //массив яркости

//---------------------------------Передача массива данных на шину-------------------------------------
void ledWrite(uint8_t* data, uint16_t size) {
  __asm__ __volatile__ (
    "CBI %[PORT], %[PIN]  \n\t" //LOW на выход пина
    "LDI r19, 200         \n\t" //счетчик сигнала reset(50мкс)
    //-----------------------------------------------------------------------------------------
    "_LOOP_DELAY_%=:      \n\t" //цикл задержки
    "NOP                  \n\t" //пропускаем цикл
    "DEC r19              \n\t" //декремент счетчика циклов
    "BRNE _LOOP_DELAY_%=  \n\t" //переход в начало цикла задержки
    //-----------------------------------------------------------------------------------------
    "CLI                  \n\t" //запретили прерывания
    "_BYTE_START_%=:      \n\t" //начало цикла отправки байта
    "LD r21, X+           \n\t" //загрузили байт из масива
    "LDI r19, 8           \n\t" //счетчик циклов байта
    //-----------------------------------------------------------------------------------------
    "_LOOP_START_%=:      \n\t" //начало цикла отправки бита
    "SBRS r21, 7          \n\t" //если бит "7" установлен то пропускаем переход
    "RJMP _SEND_NULL_%=   \n\t" //переход к функции отправить ноль
    //-----------------------------------------------------------------------------------------
    "SBI %[PORT], %[PIN]  \n\t" //HIGH на выход пина
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "CBI %[PORT], %[PIN]  \n\t" //LOW на выход пина
    "RJMP _LOOP_END_%=    \n\t" //переход в конец цикла отправки бита
    //-----------------------------------------------------------------------------------------
    "_SEND_NULL_%=:       \n\t" //функция отправить ноль
    "SBI %[PORT], %[PIN]  \n\t" //HIGH на выход пина
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "CBI %[PORT], %[PIN]  \n\t" //LOW на выход пина
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    "NOP                  \n\t" //пропускаем цикл
    //-----------------------------------------------------------------------------------------
    "_LOOP_END_%=:        \n\t" //конец цикла отправки бита
    "LSL r21              \n\t" //сдвигаем байт влево
    "DEC r19              \n\t" //декремент счетчика циклов байта
    "BRNE _LOOP_START_%=  \n\t" //переход в начало цикла отправки бита
    //-----------------------------------------------------------------------------------------
    "SBIW %[COUNT], 1     \n\t" //отнимаем от счетчика байт
    "BRNE _BYTE_START_%=  \n\t" //переход к загрузке нового байта
    "SEI                  \n\t" //разрешили прерывания
    "SBI %[PORT], %[PIN]  \n\t" //HIGH на выход пина
    :
    :"x"(data),
    [COUNT]"w"(size),
    [PORT]"I"(_SFR_IO_ADDR(BACKL_PORT)),
    [PIN]"I"(BACKL_BIT)
  );
}
//--------------------------------------Установка цвета в формате GRB------------------------------------------
void setLedGRB(uint8_t led, uint8_t G, uint8_t R, uint8_t B)
{
  ledColor[led * 3] = G;
  ledColor[led * 3 + 1] = R;
  ledColor[led * 3 + 2] = B;
  ledWrite(ledColor, sizeof(ledColor));
}
//--------------------------------------Установка по цветовой палитре------------------------------------------
void setLedColor(uint8_t led, uint8_t clr)
{
  for (uint8_t i = 0; i < 3; i++) {
    if ((clr >> i) & 0x01) ledColor[led * 3 + i] = ledBright[led];
    else ledColor[led * 3 + i] = 0;
  }
  ledWrite(ledColor, sizeof(ledColor));
}
//--------------------------------------Установка по цветовой палитре------------------------------------------
void setLedColor(uint8_t clr)
{
  for (uint8_t f = 0; f < 4; f++) {
    for (uint8_t i = 0; i < 3; i++) {
      if ((clr >> i) & 0x01) ledColor[f * 3 + i] = ledBright[f];
      else ledColor[f * 3 + i] = 0;
    }
  }
  ledWrite(ledColor, sizeof(ledColor));
}
//--------------------------------------Установка яркости------------------------------------------
void setLedBright(uint8_t led, uint8_t brt)
{
  ledBright[led] = brt;
  for (uint8_t i = 0; i < 3; i++) {
    if (ledColor[led * 3 + i]) ledColor[led * 3 + i] = brt;
  }
  ledWrite(ledColor, sizeof(ledColor));
}
//--------------------------------------Установка яркости------------------------------------------
void setLedBright(uint8_t brt)
{
  for (uint8_t f = 0; f < 4; f++) {
    ledBright[f] = brt;
    for (uint8_t i = 0; i < 3; i++) {
      if (ledColor[f * 3 + i]) ledColor[f * 3 + i] = brt;
    }
  }
  ledWrite(ledColor, sizeof(ledColor));
}
